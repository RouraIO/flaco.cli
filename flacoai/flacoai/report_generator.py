"""Report generator for code review findings."""

from typing import List, Dict, Optional
from collections import defaultdict
from flacoai.analyzers import AnalysisReport, AnalysisResult, Severity, Category


class ReviewReportGenerator:
    """Generates markdown reports from code review findings."""

    def __init__(self, io=None):
        """Initialize the report generator.

        Args:
            io: IO object for rich console output (optional)
        """
        self.io = io

    def generate_markdown(self, report: AnalysisReport, include_stats=True,
                         group_by="severity", include_snippets=True) -> str:
        """Generate a markdown report from analysis results.

        Args:
            report: AnalysisReport with findings
            include_stats: Include summary statistics
            group_by: How to group findings ("severity", "category", "file")
            include_snippets: Include code snippets in report

        Returns:
            Markdown formatted report string
        """
        lines = []

        # Header
        lines.append("# Code Review Report")
        lines.append("")

        # Summary statistics
        if include_stats:
            lines.extend(self._generate_stats_section(report))
            lines.append("")

        # Findings
        if group_by == "severity":
            lines.extend(self._group_by_severity(report, include_snippets))
        elif group_by == "category":
            lines.extend(self._group_by_category(report, include_snippets))
        elif group_by == "file":
            lines.extend(self._group_by_file(report, include_snippets))
        else:
            lines.extend(self._generate_flat_list(report, include_snippets))

        # Footer
        lines.append("")
        lines.append("---")
        lines.append(f"*Report generated by FlacoAI - Analyzed {report.files_analyzed} files in {report.duration_seconds:.2f}s*")

        return "\n".join(lines)

    def display_console(self, report: AnalysisReport):
        """Display report in rich console format."""
        if not self.io or not self.io.console:
            # Fallback to plain text
            markdown = self.generate_markdown(report)
            if self.io:
                self.io.tool_output(markdown)
            return

        from rich.panel import Panel
        from rich.table import Table
        from rich.text import Text

        # Summary panel
        stats = report.get_stats()
        summary = f"""
Files Analyzed: {report.files_analyzed}
Total Issues: {stats['total']}

Critical: {stats['critical']}
High: {stats['high']}
Medium: {stats['medium']}
Low: {stats['low']}
        """.strip()

        panel = Panel(summary, title="[bold cyan]Code Review Summary[/bold cyan]", border_style="cyan")
        self.io.console.print(panel)
        self.io.console.print("")

        # Findings by severity
        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW]:
            findings = report.get_by_severity(severity)

            if not findings:
                continue

            # Create table for this severity
            color = self._severity_color(severity)
            table = Table(title=f"{severity.value.upper()} Severity Issues ({len(findings)})",
                         border_style=color)

            table.add_column("File:Line", style="cyan")
            table.add_column("Category", style="yellow")
            table.add_column("Issue", style="white")
            table.add_column("Recommendation", style="green")

            for finding in findings[:10]:  # Limit to 10 per severity
                file_ref = f"{self._short_path(finding.file)}:{finding.line}"
                table.add_row(
                    file_ref,
                    finding.category.value,
                    finding.title,
                    finding.recommendation[:50] + "..." if len(finding.recommendation) > 50 else finding.recommendation
                )

            self.io.console.print(table)
            self.io.console.print("")

        if stats['total'] > 40:
            self.io.console.print(f"[yellow]Showing first 40 issues. Use markdown report for full details.[/yellow]")

    def save_to_file(self, report: AnalysisReport, file_path: str):
        """Save markdown report to a file.

        Args:
            report: AnalysisReport with findings
            file_path: Path to save the report
        """
        markdown = self.generate_markdown(report)

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(markdown)

            if self.io:
                self.io.tool_output(f"Report saved to {file_path}")
        except Exception as e:
            if self.io:
                self.io.tool_error(f"Failed to save report: {e}")

    def _generate_stats_section(self, report: AnalysisReport) -> List[str]:
        """Generate summary statistics section."""
        stats = report.get_stats()
        lines = []

        lines.append("## Summary")
        lines.append("")
        lines.append(f"- **Files Analyzed:** {report.files_analyzed}")
        lines.append(f"- **Total Issues:** {stats['total']}")
        lines.append(f"- **Duration:** {report.duration_seconds:.2f}s")
        lines.append("")

        lines.append("### By Severity")
        lines.append(f"- ðŸ”´ **Critical:** {stats['critical']}")
        lines.append(f"- ðŸŸ  **High:** {stats['high']}")
        lines.append(f"- ðŸŸ¡ **Medium:** {stats['medium']}")
        lines.append(f"- ðŸŸ¢ **Low:** {stats['low']}")
        lines.append("")

        return lines

    def _group_by_severity(self, report: AnalysisReport, include_snippets: bool) -> List[str]:
        """Group findings by severity."""
        lines = []

        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW]:
            findings = report.get_by_severity(severity)

            if not findings:
                continue

            icon = self._severity_icon(severity)
            lines.append(f"## {icon} {severity.value.upper()} Severity ({len(findings)} issues)")
            lines.append("")

            for i, finding in enumerate(findings, 1):
                lines.extend(self._format_finding(finding, i, include_snippets))

        return lines

    def _group_by_category(self, report: AnalysisReport, include_snippets: bool) -> List[str]:
        """Group findings by category."""
        lines = []

        for category in [Category.SECURITY, Category.PERFORMANCE, Category.QUALITY, Category.ARCHITECTURE]:
            findings = report.get_by_category(category)

            if not findings:
                continue

            lines.append(f"## {category.value.title()} Issues ({len(findings)})")
            lines.append("")

            for i, finding in enumerate(findings, 1):
                lines.extend(self._format_finding(finding, i, include_snippets))

        return lines

    def _group_by_file(self, report: AnalysisReport, include_snippets: bool) -> List[str]:
        """Group findings by file."""
        lines = []

        # Group by file
        by_file: Dict[str, List[AnalysisResult]] = defaultdict(list)
        for result in report.results:
            by_file[result.file].append(result)

        # Sort files by number of issues (descending)
        sorted_files = sorted(by_file.items(), key=lambda x: len(x[1]), reverse=True)

        for file_path, findings in sorted_files:
            lines.append(f"## {file_path} ({len(findings)} issues)")
            lines.append("")

            # Sort findings by line number
            findings.sort(key=lambda x: x.line)

            for i, finding in enumerate(findings, 1):
                lines.extend(self._format_finding(finding, i, include_snippets))

        return lines

    def _generate_flat_list(self, report: AnalysisReport, include_snippets: bool) -> List[str]:
        """Generate flat list of findings."""
        lines = []
        lines.append(f"## All Issues ({len(report.results)})")
        lines.append("")

        for i, finding in enumerate(report.results, 1):
            lines.extend(self._format_finding(finding, i, include_snippets))

        return lines

    def _format_finding(self, finding: AnalysisResult, index: int, include_snippet: bool) -> List[str]:
        """Format a single finding as markdown."""
        lines = []

        # Title with file reference
        severity_icon = self._severity_icon(finding.severity)
        lines.append(f"### {index}. {severity_icon} {finding.title}")
        lines.append("")

        # Metadata
        lines.append(f"**Location:** `{finding.file}:{finding.line}`")
        lines.append(f"**Severity:** {finding.severity.value.upper()}")
        lines.append(f"**Category:** {finding.category.value}")
        lines.append("")

        # Description
        lines.append(f"**Description:** {finding.description}")
        lines.append("")

        # Recommendation
        lines.append(f"**Recommendation:** {finding.recommendation}")
        lines.append("")

        # Code snippet
        if include_snippet and finding.code_snippet:
            lines.append("**Code:**")
            lines.append("```")
            lines.append(finding.code_snippet)
            lines.append("```")
            lines.append("")

        # References
        if finding.references:
            lines.append("**References:**")
            for ref in finding.references:
                lines.append(f"- {ref}")
            lines.append("")

        lines.append("---")
        lines.append("")

        return lines

    def _severity_icon(self, severity: Severity) -> str:
        """Get emoji icon for severity."""
        icons = {
            Severity.CRITICAL: "ðŸ”´",
            Severity.HIGH: "ðŸŸ ",
            Severity.MEDIUM: "ðŸŸ¡",
            Severity.LOW: "ðŸŸ¢",
        }
        return icons.get(severity, "âšª")

    def _severity_color(self, severity: Severity) -> str:
        """Get color for severity (for rich console)."""
        colors = {
            Severity.CRITICAL: "red",
            Severity.HIGH: "bright_red",
            Severity.MEDIUM: "yellow",
            Severity.LOW: "green",
        }
        return colors.get(severity, "white")

    def _short_path(self, file_path: str, max_length: int = 40) -> str:
        """Shorten file path for display."""
        if len(file_path) <= max_length:
            return file_path

        parts = file_path.split('/')
        if len(parts) <= 2:
            return file_path

        # Show first and last parts with ...
        return f"{parts[0]}/.../{'/'.join(parts[-2:])}"
